<?php
/**
 * @package PHPUnit Test for RedisUtil
 * @author ktty1220 <ktty1220@gmail.com>
 */

/**
 * Redis接続設定(テスト時にデータを格納したり消したりするのでテスト環境を指定する)
 */
define('TEST_REDIS_HOST', 'localhost');        // Redis接続情報: ホスト
define('TEST_REDIS_PORT', 6379);               // Redis接続情報: ポート
define('TEST_REDIS_DB', 0);                    // Redis接続情報: 使用DB
define('TEST_KEY_PREFIX', '_RedisUtilTest:');  // Redisに格納するテストデータのKEYの先頭に付けるプレフィックス

/**
 * 以下はテストコードなので編集不要
 */
ini_set('display_errors', 1);
require_once('PHPUnit/Autoload.php');
require_once(dirname(__FILE__). '/../src/RedisUtil.php');

class dummyClass {}

/**
 * Generated by PHPUnit_SkeletonGenerator on 2012-07-10 at 17:59:08.
 */
class RedisUtilTest extends PHPUnit_Framework_TestCase
{
    /**
     * @var object RedisUtil
     */
    static $object;
    /**
     * @var array Redisの型一覧
     */
    static $typeList = array('string', 'set', 'list', 'zset', 'hash');
    /**
     * @var array 重複するKEYのチェック
     */
    static $duplicateKeys = array();
    /**
     * @var array 削除したKEYのチェック
     */
    static $deletedKeys = array();
    /**
     * @var int テスト開始からの経過時間(TTLのチェック)
     */
    static $startTime;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        parent::setUp();
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {
        parent::tearDown();
    }

    /**
     * Redis接続設定(テスト時にデータを格納したり消したりするのでテスト環境を指定する)
     */
    public static function setUpBeforeClass() {
        self::$object = new RedisUtil(array(
            'host' => TEST_REDIS_HOST,
            'port' => TEST_REDIS_PORT,
            'db' => TEST_REDIS_DB,
        ));

        // Redisにテストデータが残っていれば消去
        foreach (self::$object->connection->keys(TEST_KEY_PREFIX. '*') as $testData) {
            self::$object->connection->del($testData);
        }

        self::$startTime = microtime(true);
    }

    /**
     * 全テスト終了時に接続を切断する
     */
    public static function tearDownAfterClass() {
        // Redisに保存したテストデータを消去
        foreach (self::$object->connection->keys(TEST_KEY_PREFIX. '*') as $testData) {
            self::$object->connection->del($testData);
        }

        self::$object->connection->close();
    }

    /**
     * save共通NG
     *
     * @group save
     * @group ng
     * @group common
     * @dataProvider saveCommonNGProvider
     */
    public function testCommonNG($code, $key, $value, $type, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function saveCommonNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $key: null
            array(RedisUtilException::ERR_INVALID_KEY,
            null, TEST_KEY_PREFIX. 'common_NG_value01', 'string'),
            // $key: 空文字
            array(RedisUtilException::ERR_EMPTY_KEY,
            '', TEST_KEY_PREFIX. 'common_NG_value02', 'string'),
            // $key: 配列
            array(RedisUtilException::ERR_INVALID_KEY,
            array(TEST_KEY_PREFIX. 'common_NG_test03-1', TEST_KEY_PREFIX. 'common_NG_test03-2'), 'common_NG_value03', 'set'),
            // $key: 連想配列
            array(RedisUtilException::ERR_INVALID_KEY,
            array(TEST_KEY_PREFIX. 'common_NG_test04-key' => 'common_NG_test04-value'), 'common_NG_value94', 'list'),
            // $key: true
            array(RedisUtilException::ERR_INVALID_KEY,
            true, 'common_NG_value05', 'string'),
            // $key: false
            array(RedisUtilException::ERR_INVALID_KEY,
            false, 'common_NG_value06', 'list'),
            // $key: オブジェクト
            array(RedisUtilException::ERR_INVALID_KEY,
            $dummyObject, array('common_NG_value07' => 1), 'zset'),
            // $key: 関数
            array(RedisUtilException::ERR_INVALID_KEY,
            $dummyFunc, 'common_NG_value08', 'string'),

            // $type: 存在しない型
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'common_NG_test09', 'common_NG_value09', 'aaa'),
            // $type: オブジェクト
            array(RedisUtilException::ERR_INVALID_TYPE,
            TEST_KEY_PREFIX. 'common_NG_test10', array('common_NG_value10' => 1), $dummyObject),
            // $type: 関数
            array(RedisUtilException::ERR_INVALID_TYPE,
            TEST_KEY_PREFIX. 'common_NG_test11', 'common_NG_value11', $dummyFunc),

            // $expire: 負数
            array(RedisUtilException::ERR_INVALID_EXPIRE,
            TEST_KEY_PREFIX. 'common_NG_test12', 'common_NG_value12', 'string', -1),
            // $expire: 文字列
            array(RedisUtilException::ERR_INVALID_EXPIRE,
            TEST_KEY_PREFIX. 'common_NG_test13', 'common_NG_value13', 'set', 'aaa'),
            // $expire: 小数
            array(RedisUtilException::ERR_INVALID_EXPIRE,
            TEST_KEY_PREFIX. 'common_NG_test14', 'common_NG_value14', 'list', 0.1),
            // $expire: オブジェクト
            array(RedisUtilException::ERR_INVALID_EXPIRE,
            TEST_KEY_PREFIX. 'common_NG_test15', array('common_NG_value15' => 1), 'zset', $dummyObject),
            // $expire: 関数
            array(RedisUtilException::ERR_INVALID_EXPIRE,
            TEST_KEY_PREFIX. 'common_NG_test16', 'common_NG_value16', 'set', $dummyFunc),
        );
    }

    /**
     * stringの保存OK
     *
     * @group string
     * @group save
     * @group ok
     * @dataProvider stringOKProvider
     */
    public function testSaveStringOK($key, $value, $type = 'dummy', $expire = 0) {
        if ($type !== 'dummy') {
            $ret = self::$object->save($key, $value, $type, $expire);
        } else {
            $ret = self::$object->save($key, $value);
        }
        $expected = true;
        $this->assertEquals($expected, $ret);
    }

    // provider
    public static function stringOKProvider() {
        return array(
            // $type省略
            array(TEST_KEY_PREFIX. 'string_OK_test01', 'string_OK_value01'),
            // $type: null
            array(TEST_KEY_PREFIX. 'string_OK_test02', 'string_OK_value02', null),
            // $type指定
            array(TEST_KEY_PREFIX. 'string_OK_test03', 'string_OK_value03', 'string', 3600),
            // $type: 大文字 & $expire: null
            array(TEST_KEY_PREFIX. 'string_OK_test04', 'string_OK_value04', 'STRING', null),

            // $value: 数値
            array(TEST_KEY_PREFIX. 'string_OK_test05', 1000),
            // $value: 小数
            array(TEST_KEY_PREFIX. 'string_OK_test06', 0.01, null, 900),

            // $value上書き & $expire: 数値文字列
            array(TEST_KEY_PREFIX. 'string_OK_test06', 0.1, null, '36000'),
        );
    }

    /**
     * stringの保存NG
     *
     * @group string
     * @group save
     * @group ng
     * @dataProvider stringNGProvider
     */
    public function testSaveStringNG($code, $key, $value, $type = null, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function stringNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $value: null
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'string_NG_test01', null),
            // $value: 配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'string_NG_test02', array('string_NG_value02-1', 'string_NG_value02-2')),
            // $value: 連想配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'string_NG_test03', array('string_NG_value03-key' =>  'string_NG_value03-value'), 'string'),
            // $value: オブジェクト
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'string_NG_test04', $dummyObject, 'string'),
            // $value: 関数
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'string_NG_test05', $dummyFunc),
            // $value: true
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'string_NG_test06', true),
            // $value: false
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'string_NG_test07', false),
        );
    }

    /**
     * setの保存OK
     *
     * @group set
     * @group save
     * @group ok
     * @dataProvider setOKProvider
     */
    public function testSaveSetOK($key, $value, $type = 'set', $expire = 0) {
        $ret = self::$object->save($key, $value, $type, $expire);
        // setの戻り値は基本trueで、すでにメンバーが登録済みだった場合はfalse
        $expected = array();
        $exists = (isset(self::$duplicateKeys[$key])) ? self::$duplicateKeys[$key] : array();
        if (is_array($value)) {
            foreach ($value as $v) {
                array_push($expected, (!in_array($v, $exists)));
            }
        } else {
            array_push($expected, (!in_array($value, $exists)));
        }
        self::$duplicateKeys[$key] = (is_array($value)) ? $value : array($value);
        $this->assertSame($expected, $ret);
    }

    // provider
    public static function setOKProvider() {
        return array(
            // $value: 値1つの配列
            array(TEST_KEY_PREFIX. 'set_OK_test01', array('set_OK_value01')),
            // $value: 値複数の配列
            array(TEST_KEY_PREFIX. 'set_OK_test02', array('set_OK_value02-1', 'set_OK_value02-2')),
            // $value: 文字列 & $expire: null
            array(TEST_KEY_PREFIX. 'set_OK_test03', 'set_OK_value03', 'set', null),
            // $value: 数値
            array(TEST_KEY_PREFIX. 'set_OK_test04', 2000),
            // $value: 小数 & $expire: 0
            array(TEST_KEY_PREFIX. 'set_OK_test05', 0.02, 'set', 0),
            // $value: 文字列と数値の混合配列
            array(TEST_KEY_PREFIX. 'set_OK_test06', array('set_OK_value06', 2000, 0.02)),

            // $type: 大文字
            array(TEST_KEY_PREFIX. 'set_OK_test07', array('set_OK_value07-1', 'set_OK_value07-2'), 'SET'),

            // memberがすでに存在
            array(TEST_KEY_PREFIX. 'set_OK_test07', array('set_OK_value07-1', 'set_OK_value07-3'), 'set', 86400),
        );
    }

    /**
     * setの保存NG
     *
     * @group set
     * @group save
     * @group ng
     * @dataProvider setNGProvider
     */
    public function testSaveSetNG($code, $key, $value, $type = null, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function setNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $value: null
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'set_NG_test01', null, 'set'),
            // $value: 空配列
            array(RedisUtilException::ERR_EMPTY_ARRAY,
            TEST_KEY_PREFIX. 'set_NG_test02', array(), 'set'),
            // $value: 連想配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'set_NG_test03', array('set_NG_value03-key'=>'set_NG_value03-value'), 'set'),

            // $value: オブジェクト
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'set_NG_test04', $dummyObject, 'set'),
            // $valueの一部: オブジェクト
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'set_NG_test05', array('set_NG_value05', $dummyObject), 'set'),

            // $value: 関数
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'set_NG_test06', $dummyFunc, 'set'),
            // $valueの一部: 関数
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'set_NG_test07', array('set_NG_value07', $dummyFunc), 'set'),

            // $value: true
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'set_NG_test08', true, 'set'),
            // $valueの一部: false
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'set_NG_test09', array(false, 'set_NG_value09'), 'set'),

            // $valueの一部: null
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'set_NG_test10', array('set_NG_value10', null), 'set'),

            // $type省略
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'set_NG_test11', array('set_NG_value11-1', 'set_NG_value11-2')),
        );
    }

    /**
     * listの保存OK
     *
     * @group list
     * @group save
     * @group ok
     * @dataProvider listOKProvider
     */
    public function testSaveListOK($key, $value, $type = 'list', $expire = 0) {
        $ret = self::$object->save($key, $value, $type, $expire);
        // listの戻り値はそのリストに登録されている個数
        $expected = array();
        $exists = (isset(self::$duplicateKeys[$key])) ? self::$duplicateKeys[$key] : array();
        if (is_array($value)) {
            $vcount = count($value);
            for ($i = 0; $i < $vcount; $i++) {
                array_push($expected, count($exists) + $i + 1);
            }
        } else {
            array_push($expected, count($exists) + 1);
        }
        self::$duplicateKeys[$key] = (is_array($value)) ? $value : array($value);
        $this->assertSame($expected, $ret);
    }

    // provider
    public static function listOKProvider() {
        return array(
            // $value: 値1つの配列
            array(TEST_KEY_PREFIX. 'list_OK_test01', array('list_OK_value01')),
            // $value: 値複数の配列
            array(TEST_KEY_PREFIX. 'list_OK_test02', array('list_OK_value02-1', 'list_OK_value02-2', 'list_OK_value02-3', 'list_OK_value02-4', 'list_OK_value02-5', 'list_OK_value02-6', 'list_OK_value02-7', 'list_OK_value02-8', 'list_OK_value02-9')),
            // $value: 文字列 & $expire: null
            array(TEST_KEY_PREFIX. 'list_OK_test03', 'list_OK_value03', 'list', null),
            // $value: 数値
            array(TEST_KEY_PREFIX. 'list_OK_test04', 3000),
            // $value: 小数 & $expire: 数値文字列
            array(TEST_KEY_PREFIX. 'list_OK_test05', 0.03, 'list', '600'),
            // $value: 文字列と数値の混合配列
            array(TEST_KEY_PREFIX. 'list_OK_test06', array('list_OK_value06', 3000, 0.03)),
            // $type: 大文字 & 存在する$keyに値を追加
            array(TEST_KEY_PREFIX. 'list_OK_test06', 'list_OK_value06-X', 'LIST'),
        );
    }

    /**
     * listの保存NG
     *
     * @group list
     * @group save
     * @group ng
     * @dataProvider listNGProvider
     */
    public function testSaveListNG($code, $key, $value, $type = null, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function listNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $value: null
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'list_NG_test01', null, 'list'),
            // $value: 空配列
            array(RedisUtilException::ERR_EMPTY_ARRAY,
            TEST_KEY_PREFIX. 'list_NG_test02', array(), 'list'),
            // $value: 連想配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'list_NG_test03', array('list_NG_value03-key'=>'list_NG_value03-value'), 'list'),

            // $value: オブジェクト
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'list_NG_test04', $dummyObject, 'list'),
            // $valueの一部: オブジェクト
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'list_NG_test05', array('list_NG_value05', $dummyObject, 'list')),

            // $value: 関数
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'list_NG_test06', $dummyFunc, 'list'),
            // $valueの一部: 関数
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'list_NG_test07', array('list_NG_value07', $dummyFunc), 'list'),

            // $value: true
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'list_NG_test08', true, 'list'),
            // $valueの一部: false
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'list_NG_test09', array(false, 'list_NG_value09'), 'list'),

            // $valueの一部: null
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'list_NG_test10', array('list_NG_value10', null), 'list'),

            // $type省略
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'list_NG_test11', array('list_NG_value11-1', 'list_NG_value11-2')),
        );
    }

    /**
     * zsetの保存OK
     *
     * @group zset
     * @group save
     * @group ok
     * @dataProvider zsetOKProvider
     */
    public function testSaveZsetOK($key, $value, $type = 'zset', $expire = 0) {
        $ret = self::$object->save($key, $value, $type, $expire);
        // zsetの戻り値は成功:1、失敗:0
        $expected = array();
        $exists = (isset(self::$duplicateKeys[$key])) ? self::$duplicateKeys[$key] : array();
        if (is_array($value)) {
            foreach ($value as $k => $v) {
                array_push($expected, isset($exists[$k]) ? 0 : 1);
            }
        } else {
            array_push($expected, isset($exists[$value]) ? 0 : 1);
        }
        self::$duplicateKeys[$key] = (is_array($value)) ? $value : array($value);
        $this->assertSame($expected, $ret);
    }

    // provider
    public static function zsetOKProvider() {
        return array(
            // $value: 1つのインデックス=>スコアのペア
            array(TEST_KEY_PREFIX. 'zset_OK_test01', array('zset_OK_value01' => 10)),
            // $value: 複数のインデックス=>スコアのペア
            array(TEST_KEY_PREFIX. 'zset_OK_test02', array('zset_OK_value02-1' => 20, 'zset_OK_value02-2' => 21, 'zset_OK_value02-3' => 25, 'zset_OK_value02-4' => 29, 'zset_OK_value02-5' => 26, 'zset_OK_value02-6' => 24, 'zset_OK_value02-7' => 23, 'zset_OK_value02-8' => 28, 'zset_OK_value02-9' => 22)),
            // $valueのインデックス: 数値
            array(TEST_KEY_PREFIX. 'zset_OK_test03', array(3 => 30)),
            // $valueのインデックス: 文字列と数値の混合
            array(TEST_KEY_PREFIX. 'zset_OK_test04', array('zset_OK_value04' => 40, 4 => 41)),

            // $valueのスコア: 小数
            array(TEST_KEY_PREFIX. 'zset_OK_test05', array(5 => 0.05)),
            // $valueのスコア: 数値文字列
            array(TEST_KEY_PREFIX. 'zset_OK_test06', array('zset_OK_value06' => '60')),
            // $valueのスコア: 0 & $expire: 数値文字列
            array(TEST_KEY_PREFIX. 'zset_OK_test07', array('zset_OK_value07' => 0), 'zset', '37000'),
            // $valueのスコア: 負数 & $expire: null
            array(TEST_KEY_PREFIX. 'zset_OK_test08', array('zset_OK_value08-1' => -1), 'zset', null),
            // $valueのスコア上書き
            array(TEST_KEY_PREFIX. 'zset_OK_test08', array('zset_OK_value08-1' => -10, 'zset_OK_value08-2' => 0)),

            // $type: 大文字 & $expire: 0
            array(TEST_KEY_PREFIX. 'zset_OK_test09', array('zset_OK_value09' => 90), 'ZSET', 0),
        );
    }

    /**
     * zsetの保存NG
     *
     * @group zset
     * @group save
     * @group ng
     * @dataProvider zsetNGProvider
     */
    public function testSaveZsetNG($code, $key, $value, $type = null, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function zsetNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $value: null
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'zset_NG_test01', null, 'zset'),
            // $value: 空配列
            array(RedisUtilException::ERR_EMPTY_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test02', array(), 'zset'),
            // $value: 配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'zset_NG_test03', array('zset_NG_value03-1', 'zset_NG_value03-2'), 'zset'),

            // $value: 文字列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'zset_NG_test04', 'zset_NG_value04', 'zset'),
            // $valueのスコア: 文字列
            array(RedisUtilException::ERR_NON_NUMERIC_SCORE,
            TEST_KEY_PREFIX. 'zset_NG_test05', array('zset_NG_value05' => 'xxx'), 'zset'),

            // $value: 空文字
            array(RedisUtilException::ERR_EMPTY_VALUE,
            TEST_KEY_PREFIX. 'zset_NG_test06', '', 'zset'),
            // $valueのインデックス: 空文字
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test07', array('' => 10, 'zset_NG_value07-2' => 18), 'zset'),
            // $valueのスコア: 空文字
            array(RedisUtilException::ERR_NON_NUMERIC_SCORE,
            TEST_KEY_PREFIX. 'zset_NG_test08', array('zset_NG_value08-1' => ''), 'zset'),

            // $value: オブジェクト
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'zset_NG_test08', $dummyObject, 'zset'),
            // $valueのスコア: オブジェクト
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test09', array('zset_NG_value09' => $dummyObject), 'zset'),

            // $value: 関数
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'zset_NG_test10', $dummyFunc, 'zset'),
            // $valueのスコア: 関数
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test11', array('zset_NG_value11' => $dummyFunc), 'zset'),

            // $value: true
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'zset_NG_test12', true, 'zset'),
            // $valueのインデックス: false(連想配列のインデックスにboolを入れてもintに変換されてしまう模様)
            //array(RedisUtilException::ERR_INVALID_VALUE,
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'zset_NG_test13', array(false => 13), 'zset'),
            // $valueのスコア: true
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test14', array('zset_NG_value14' => true), 'zset'),

            // $valueのインデックス: null
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test15', array(null => 15), 'zset'),
            // $valueのスコア: null
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'zset_NG_test16', array('zset_NG_value16' => null), 'zset'),

            // $type省略
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'zset_NG_test17', array('zset_NG_value17' => 17)),
        );
    }

    /**
     * hashの保存OK
     *
     * @group hash
     * @group save
     * @group ok
     * @dataProvider hashOKProvider
     */
    public function testSaveHashOK($key, $value, $type = 'hash', $expire = 0) {
        $ret = self::$object->save($key, $value, $type, $expire);
        // hashの戻り値は新規:1、更新:0、失敗:false
        $expected = array();
        $exists = (isset(self::$duplicateKeys[$key])) ? self::$duplicateKeys[$key] : array();
        if (is_array($value)) {
            foreach ($value as $k => $v) {
                array_push($expected, isset($exists[$k]) ? 0 : 1);
            }
        } else {
            array_push($expected, in_array($value, $exists) ? 0 : 1);
        }
        self::$duplicateKeys[$key] = (is_array($value)) ? $value : array($value);
        $this->assertSame($expected, $ret);
    }

    // provider
    public static function hashOKProvider() {
        return array(
            // $value: 1つの連想配列
            array(TEST_KEY_PREFIX. 'hash_OK_test01', array('hash_OK_value01-key' => 'hash_OK_value01-value')),
            // $value: 複数の連想配列
            array(TEST_KEY_PREFIX. 'hash_OK_test02', array('hash_OK_value02-01-key' => 'hash_OK_value02-01-value', 'hash_OK_value02-02-key' => 'hash_OK_value02-02-value')),

            // $valueのインデックスが数値
            array(TEST_KEY_PREFIX. 'hash_OK_test03', array(3 => 'hash_OK_value03'), 'hash', 7200),
            // $valueのインデックスが文字列と数値の混合
            array(TEST_KEY_PREFIX. 'hash_OK_test04', array('hash_OK_value04' => 'hash_OK_value04', 4 => 40, 444 => 444)),
            // 既存の$keyに連想配列追加 & $expire: 0
            array(TEST_KEY_PREFIX. 'hash_OK_test04', array('hash_OK_value04' => 'hash_OK_value04-X', 4 => 400, '44' => 'hash_OK_value04-44'), 'hash', 0),
            // $type: 大文字 & $expire: 0
            array(TEST_KEY_PREFIX. 'hash_OK_test05', array('hash_OK_value05' => 50), 'HASH'),
        );
    }

    /**
     * hashの保存NG
     *
     * @group hash
     * @group save
     * @group ng
     * @dataProvider hashNGProvider
     */
    public function testSaveHashNG($code, $key, $value, $type = null, $expire = 0) {
        $this->setExpectedException('RedisUtilException', null, $code);
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function hashNGProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            // $value: null
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'hash_NG_test01', null, 'hash'),
            // $value: 空配列
            array(RedisUtilException::ERR_EMPTY_ARRAY,
            TEST_KEY_PREFIX. 'hash_NG_test02', array(), 'hash'),
            // $value: 配列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'hash_NG_test03', array('hash_NG_value03-1', 'hash_NG_value03-2'), 'hash'),

            // $value: 文字列
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'hash_NG_test04', 'hash_NG_value04', 'hash'),

            // $value: 空文字
            array(RedisUtilException::ERR_EMPTY_VALUE,
            TEST_KEY_PREFIX. 'hash_NG_test05', '', 'hash'),
            // $valueのインデックス: 空文字
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'hash_NG_test06', array('' => 'hash_NG_value06-value'), 'hash'),

            // $value: オブジェクト
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'hash_NG_test07', $dummyObject, 'hash'),
            // $valueの値: オブジェクト
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'hash_NG_test08', array('hash_NG_value08-key' => $dummyObject), 'hash'),

            // $value: 関数
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'hash_NG_test09', $dummyFunc, 'hash'),
            // $valueの値: 関数
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'hash_NG_test10', array('hash_NG_value10-key' => $dummyFunc), 'hash'),

            // $value: true
            array(RedisUtilException::ERR_INVALID_VALUE,
            TEST_KEY_PREFIX. 'hash_NG_test11', true, 'hash'),
            // $valueのインデックス: false(連想配列のインデックスにboolを入れてもintに変換されてしまう模様)
            //array(RedisUtilException::ERR_INVALID_ARRAY,
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'hash_NG_test12', array(false => 'hash_NG_value12-value'), 'hash'),

            // $valueのインデックス: null
            array(RedisUtilException::ERR_INVALID_ARRAY,
            TEST_KEY_PREFIX. 'hash_NG_test13', array(null => 'hash_NG_value13-value'), 'hash'),

            // $type省略
            array(RedisUtilException::ERR_VALUE_TYPE_MISSMATCH,
            TEST_KEY_PREFIX. 'hash_NG_test14', array('hash_NG_value14' => 14)),
        );
    }

    /**
     * Redisに保存済みのKEYと保存しようとするデータのKEYの型相違
     *
     * @group save
     * @group ng
     * @dataProvider keyMissMatchNGProvider
     */
    public function testKeyMissMatchNG($key, $value, $type = null, $expire = 0) {
        // 無理矢理型だけ変えているので、必ずしもERR_EXISTING_KEY_MISSMATCHになるわけではない。
        //$this->setExpectedException('RedisUtilException', null, RedisUtilException::ERR_EXISTING_KEY_MISSMATCH);
        $this->setExpectedException('RedisUtilException');
        $ret = self::$object->save($key, $value, $type, $expire);
    }

    // provider
    public static function keyMissMatchNGProvider() {
        // 各プロバイダからRedisに保存済みのKEYを取得してtypeを変更したものを作成
        $data = array();
        foreach (self::$typeList as $t) {
            eval('$keys = self::'. $t. 'OKProvider();');
            foreach (self::$typeList as $tt) {
                if ($t !== $tt) {
                    array_push($data, array($keys[0][0], $keys[0][1], $tt));
                }
            }
        }
        return $data;
    }

    /**
     * expire指定
     *
     * @group find
     * @group ok
     * @dataProvider findTTLProvider
     */
    public function testFindTTL($key, $expire) {
        $ttl = self::$object->connection->ttl($key);
        // 誤差1秒くらいは許可
        $elapsedTime = microtime(true) + 1;
        $this->assertTrue($ttl <= $expire && $ttl > $expire - ceil($elapsedTime - self::$startTime));
    }

    // provider
    public static function findTTLProvider() {
        $provDataHash = array();
        $provData = array();
        foreach (self::$typeList as $t) {
            eval('$datas = self::'. $t. 'OKProvider();');
            foreach ($datas as $data) {
                if (count($data) > 3 && is_numeric($data[3]) && $data[3] > 0) {
                    $provDataHash[$data[0]] = $data[3];
                }
            }
        }
        foreach ($provDataHash as $k => $v) {
            array_push($provData, array($k, $v));
        }
        return $provData;
    }

    /**
     * find実行結果を取得
     */
    public static function findExec($keyPattern, $option = null) {
        $ret = self::$object->find($keyPattern, $option);
        $actual = array();
        if (is_object($ret) && get_class($ret) === 'RedisIterator') {
            foreach ($ret as $k => $v) {
                // set型はRedis保存時に並び順が不定(?)になるようなので、比較用にソートする
                if (preg_match('/:set_/', $k)) sort($v);
                array_push($actual, array('key' => $k, 'value' => $v, 'iterator' => true));
            }
        } elseif (!is_null($ret)) {
            // set型はRedis保存時に並び順が不定(?)になるようなので、比較用にソートする
            if (is_array($ret) && preg_match('/:set_/', $keyPattern)) sort($ret);
            array_push($actual, array('key' => $keyPattern, 'value' => $ret, 'iterator' => false));
        }
        sort($actual);
        return $actual;
    }

    /**
     * findの予想戻り値をプロバイダから作成
     */
    public static function makeExpected($keyPattern, $option = null) {
        $reverse = null;
        $limit = null;
        if (is_array($option)) extract($option);

        $isIterator = (is_array($keyPattern) || preg_match('/[\*\?\[]/', $keyPattern));

        // キーパターンを正規表現に変換
        $keyArray = (is_array($keyPattern)) ? $keyPattern : array($keyPattern);
        for ($i = 0; $i < count($keyArray); $i++) {
            $keyArray[$i] = str_replace('*', '.*', $keyArray[$i]);
            $keyArray[$i] = str_replace('?', '.', $keyArray[$i]);
            $keyArray[$i] = "/^$keyArray[$i]$/i";
        }

        $expected = array();
        $expectedHash = array();
        $isList = array();
        $isZset = array();
        foreach (self::$typeList as $t) {
            eval('$datas = self::'. $t. 'OKProvider();');
            foreach ($datas as $data) {
                $key = $data[0];
                $value = $data[1];

                // KEY削除済み
                if (in_array($key, self::$deletedKeys)) continue;

                $isMatch = false;
                foreach ($keyArray as $k) {
                    if (preg_match($k, $key)) {
                        $isMatch = true;
                        break;
                    }
                }
                if (!$isMatch) continue;

                if ($t === 'list') array_push($isList, $key);
                if ($t === 'zset') array_push($isZset, $key);

                if (!is_null($value)) {
                    if ($t === 'string') {
                        $value = (string) $value;
                    } else {
                        // string以外はarrayで返るので、それに合わせる
                        if (!is_array($value)) {
                            $value = array((string) $value);
                        } elseif ($t !== 'zset') {
                            // Redisで取得した値はzset以外は全て文字列なので、それに合わせる
                            foreach ($value as $k => $v) $value[$k] = (string) $v;
                        } else {
                            // zsetはdouble
                            foreach ($value as $k => $v) $value[$k] = (double) $v;
                        }
                    }

                    // 上書きのケースもあるので、この時点では連想配列に格納
                    if ($t === 'string') {
                        $expectedHash[$key] = $value;
                    } elseif ($t === 'set' || $t === 'list') {
                        if (array_key_exists($key, $expectedHash)) {
                            $expectedHash[$key] = array_merge($expectedHash[$key], $value);
                            $expectedHash[$key] = array_unique($expectedHash[$key]);
                        } else {
                            $expectedHash[$key] = $value;
                        }
                        // set型はRedis保存時に並び順が不定(?)になるようなので、比較用にソートする
                        if ($t === 'set') sort($expectedHash[$key]);
                    } else {
                        if (array_key_exists($key, $expectedHash)) {
                            foreach ($value as $k => $v) {
                                $expectedHash[$key][$k] = $v;
                            }
                        } else {
                            $expectedHash[$key] = $value;
                        }
                    }
                }
            }
        }

        // 上書き済の連想配列から配列に変換
        foreach ($expectedHash as $k => $v) {
            if (in_array($k, $isList, true)) {
                // list型の$option対応
                if ($reverse === true) $v = array_reverse($v);
                if (!is_null($limit)) while (count($v) > $limit) array_pop($v);
            } elseif (in_array($k, $isZset, true)) {
                // zset型の$option対応
                if ($reverse === true) {
                    arsort($v, SORT_NUMERIC);
                } else {
                    asort($v, SORT_NUMERIC);
                }
                if (!is_null($limit)) while (count($v) > $limit) array_pop($v);
            }
            array_push($expected, array('key' => $k, 'value' => $v, 'iterator' => $isIterator));
        }
        sort($expected);
        return $expected;
    }

    /**
     * find: KEYパターン(*) - $option指定なし
     *
     * @group find
     * @group ok
     */
    public function testFindAsterisk() {
        $key = TEST_KEY_PREFIX. '*';
        $actual = self::findExec($key);
        $expected = self::makeExpected($key);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(*) - reverse指定
     *
     * @group find
     * @group ok
     */
    public function testFindAsteriskReverse() {
        $key = TEST_KEY_PREFIX. 'zset*';
        $opt = array('reverse' => true);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(*) - limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindAsteriskLimit() {
        $key = TEST_KEY_PREFIX. '*set_*';
        $opt = array('limit' => 5);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(*) - reverse & limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindAsteriskReverseLimit() {
        $key = TEST_KEY_PREFIX. '*t*';
        $opt = array('reverse' => true, 'limit' => 4);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(?) - $option指定なし
     *
     * @group find
     * @group ok
     */
    public function testFindQuestion() {
        $key = TEST_KEY_PREFIX. '*test?3*';
        $actual = self::findExec($key);
        $expected = self::makeExpected($key);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(?) - reverse指定
     *
     * @group find
     * @group ok
     */
    public function testFindQuestionReverse() {
        $key = TEST_KEY_PREFIX. '*test?2*';
        $opt = array('reverse' => true);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(?) - limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindQuestionLimit() {
        $key = TEST_KEY_PREFIX. '*test0?*';
        $opt = array('limit' => 3);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン(?) - reverse & limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindQuestionReverseLimit() {
        $key = TEST_KEY_PREFIX. '*tes?0*';
        $opt = array('reverse' => true, 'limit' => 2);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン([]) - $option指定なし
     *
     * @group find
     * @group ok
     */
    public function testFindParenthesis() {
        $key = TEST_KEY_PREFIX. '*test0[567]';
        $actual = self::findExec($key);
        $expected = self::makeExpected($key);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン([]) - reverse指定
     *
     * @group find
     * @group ok
     */
    public function testFindParenthesisReverse() {
        $key = TEST_KEY_PREFIX. '*test[0123][135]';
        $opt = array('reverse' => true);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン([]) - limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindParenthesisLimit() {
        $key = TEST_KEY_PREFIX. '*test0[2468]';
        $opt = array('limit' => 1);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEYパターン([]) - reverse & limit指定
     *
     * @group find
     * @group ok
     */
    public function testFindParenthesisReverseLimit() {
        $key = TEST_KEY_PREFIX. '*test0[456]';
        $opt = array('reverse' => true, 'limit' => 5);
        $actual = self::findExec($key, $opt);
        $expected = self::makeExpected($key, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * find: KEY単一 - $option指定なし
     *
     * @group find
     * @group ok
     * @dataProvider findWordProvider
     */
    public function testFindWord($key, $expectedValue) {
        $actual = self::findExec($key);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expectedValue), count($actual[0]['value']));

        // 内容の比較
        $this->assertSame($expectedValue, $actual[0]['value']);
    }

    // provider
    public static function findWordProvider() {
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*');
        $provData = array();
        foreach ($expected as $e) {
            array_push($provData, array($e['key'], $e['value']));
        }
        return $provData;
    }

    /**
     * find: KEY単一 - reverse指定
     *
     * @group find
     * @group ok
     * @dataProvider findWordProviderReverse
     */
    public function testFindWordReverse($key, $expectedValue) {
        $actual = self::findExec($key, array('reverse' => true));

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expectedValue), count($actual[0]['value']));

        // 内容の比較
        $this->assertSame($expectedValue, $actual[0]['value']);
    }

    // provider
    public static function findWordProviderReverse() {
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*', array('reverse' => true));
        $provData = array();
        foreach ($expected as $e) {
            array_push($provData, array($e['key'], $e['value']));
        }
        return $provData;
    }

    /**
     * find: KEY単一 - limit指定
     *
     * @group find
     * @group ok
     * @dataProvider findWordProviderLimit
     */
    public function testFindWordLimit($key, $expectedValue) {
        $actual = self::findExec($key, array('limit' => 4));

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expectedValue), count($actual[0]['value']));

        // 内容の比較
        $this->assertSame($expectedValue, $actual[0]['value']);
    }

    // provider
    public static function findWordProviderLimit() {
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*', array('limit' => 4));
        $provData = array();
        foreach ($expected as $e) {
            array_push($provData, array($e['key'], $e['value']));
        }
        return $provData;
    }

    /**
     * find: KEY単一 - reverse & limit指定
     *
     * @group find
     * @group ok
     * @dataProvider findWordProviderReverseLimit
     */
    public function testFindWordReverseLimit($key, $expectedValue) {
        $actual = self::findExec($key, array('reverse' => true, 'limit' => 5));

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expectedValue), count($actual[0]['value']));

        // 内容の比較
        $this->assertSame($expectedValue, $actual[0]['value']);
    }

    // provider
    public static function findWordProviderReverseLimit() {
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*', array('reverse' => true, 'limit' => 5));
        $provData = array();
        foreach ($expected as $e) {
            array_push($provData, array($e['key'], $e['value']));
        }
        return $provData;
    }

    /**
     * find: 配列指定
     *
     * @group find
     * @group array
     * @group ok
     * @dataProvider findArrayProvider
     */
    public function testFindArray() {
        $keys = func_get_args();
        $opt = array('reverse' => true, 'limit' => 15);
        $actual = self::findExec($keys, $opt);
        $expected = self::makeExpected($keys, $opt);

        // 0件同士でチェックしないように
        $this->assertTrue(count($actual) > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        $ecount = count($expected);
        for ($i = 0; $i < $ecount; $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    public static function expandKeyArray() {
        $keys = func_get_args();
        $provData = array();
        $kcount = count($keys);
        for ($i = 0; $i < $kcount; $i++) {
            $keyArray = array();

            // 順番を変えてみる
            array_push($keys, array_shift($keys));
            foreach ($keys as $k) {
                // 配列内のKEY数を変えてみる
                array_push($keyArray, $k);
                array_push($provData, $keyArray);
            }
        }
        return $provData;
    }

    public static function findArrayProvider() {
        return self::expandKeyArray(
            TEST_KEY_PREFIX. 'zset_OK_test01',
            TEST_KEY_PREFIX. '*set*',
            TEST_KEY_PREFIX. 'hash_OK_test?2',
            TEST_KEY_PREFIX. '*s[et]*'
        );
    }

    /**
     * find: 存在しないKEY
     *
     * @group find
     * @group ng
     * @dataProvider notExistsProvider
     */
    public function testFindNotExists($key) {
        $this->assertNull(self::$object->find($key));
    }

    /**
     * delete: 存在しないKEY
     *
     * @group delete
     * @group ng
     * @dataProvider notExistsProvider
     */
    public function testDeleteNotExists($key) {
        $this->assertEquals(0, self::$object->delete($key));
    }

    // provider
    public static function notExistsProvider() {
        return self::expandKeyArray('',
            TEST_KEY_PREFIX. 'NotExistsKey',
            TEST_KEY_PREFIX. 'NotExists*',
            TEST_KEY_PREFIX. 'NotExists?ey',
            TEST_KEY_PREFIX. 'NotExists[ke]ey'
        );
    }

    /**
     * find: KEYに指定できない型
     *
     * @group find
     * @group ng
     * @dataProvider invalidKeyProvider
     */
    public function testFindInvalidKey() {
        $keys = func_get_args();
        $this->setExpectedException('RedisUtilException', null, RedisUtilException::ERR_INVALID_KEY);
        self::$object->find($keys);
    }

    /**
     * delete: KEYに指定できない型
     *
     * @group delete
     * @group ng
     * @dataProvider invalidKeyProvider
     */
    public function testDeleteInvalidKey() {
        $keys = func_get_args();
        $this->setExpectedException('RedisUtilException', null, RedisUtilException::ERR_INVALID_KEY);
        self::$object->delete($keys);
    }

    // provider
    public static function invalidKeyProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return self::expandKeyArray(null, $dummyObject, $dummyFunc, true, false);
    }

    /**
     * find: 不正なオプション
     *
     * @group find
     * @group ng
     * @dataProvider invalidOptionProvider
     */
    public function testFindInvalidOption($code, $reverse, $limit) {
        $this->setExpectedException('RedisUtilException', null, $code);
        self::$object->find(TEST_KEY_PREFIX. '*', array('reverse' => $reverse, 'limit' => $limit));
    }

    // provider
    public static function invalidOptionProvider() {
        $dummyObject = new dummyClass();
        $dummyFunc = function() {};
        return array(
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, 1, null),
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, 'true', 10),
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, array(true, false), 20),
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, array('reverse' => true), 30),
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, $dummyObject, 40),
            array(RedisUtilException::ERR_NON_BOOL_REVERSE, $dummyFunc, 50),
            array(RedisUtilException::ERR_NON_INT_LIMIT, null, -1),
            array(RedisUtilException::ERR_NON_INT_LIMIT, true, 'xxx'),
            array(RedisUtilException::ERR_NON_INT_LIMIT, false, array(10, 20)),
            array(RedisUtilException::ERR_NON_INT_LIMIT, null, array('limit' => 30)),
            array(RedisUtilException::ERR_NON_INT_LIMIT, true, $dummyObject),
            array(RedisUtilException::ERR_NON_INT_LIMIT, false, $dummyFunc),
        );
    }

    /**
     * 全予想戻り値から指定したKEYを削除
     */
    public static function removeFromExpected($remove = array()) {
        $all = self::makeExpected(TEST_KEY_PREFIX. '*');
        $acount = count($all);
        $removeKeys = array();
        foreach ($remove as $r) {
            array_push($removeKeys, $r['key']);
        }
        for ($i = 0; $i < $acount; $i++) {
            $akey = $all[$i]['key'];
            if (in_array($akey, $removeKeys)) {
                array_push(self::$deletedKeys, $akey);
                unset($all[$i]);
            }
        }
        sort($all);
        return $all;
    }

    /**
     * delete: KEY単一
     *
     * @group delete
     * @group ok
     */
    public function testDeleteWord() {
        $actual = self::$object->delete(TEST_KEY_PREFIX. 'string_OK_test04');
        $expected = self::makeExpected(TEST_KEY_PREFIX. 'string_OK_test04');

        // 0件同士でチェックしないように
        $this->assertTrue($actual > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), $actual);

        // 残ったKEYの比較
        $actual = self::findExec(TEST_KEY_PREFIX. '*');
        $expected = self::removeFromExpected($expected);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        for ($i = 0; $i < count($expected); $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * delete: KEYパターン(?)
     *
     * @group delete
     * @group ok
     */
    public function testDeleteQuestion() {
        $actual = self::$object->delete(TEST_KEY_PREFIX. '?set_*');
        $expected = self::makeExpected(TEST_KEY_PREFIX. '?set_*');

        // 0件同士でチェックしないように
        $this->assertTrue($actual > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), $actual);

        // 残ったKEYの比較
        $actual = self::findExec(TEST_KEY_PREFIX. '*');
        $expected = self::removeFromExpected($expected);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        for ($i = 0; $i < count($expected); $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    /**
     * delete: KEYパターン([])
     *
     * @group delete
     * @group ok
     */
    public function testDeleteParenthesis() {
        $actual = self::$object->delete(TEST_KEY_PREFIX. '*test0[567]');
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*test0[567]');

        // 0件同士でチェックしないように
        $this->assertTrue($actual > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), $actual);

        // 残ったKEYの比較
        $actual = self::findExec(TEST_KEY_PREFIX. '*');
        $expected = self::removeFromExpected($expected);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        for ($i = 0; $i < count($expected); $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }

    }

    /**
     * delete: 配列指定
     *
     * @group delete
     * @group array
     * @group ok
     * @dataProvider deleteArrayProvider
     */
    public function testDeleteArray() {
        $keys = func_get_args();
        $actual = self::$object->delete($keys);
        $expected = self::makeExpected($keys);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), $actual);

        // 残ったKEYの比較
        $actual = self::findExec(TEST_KEY_PREFIX. '*');
        $expected = self::removeFromExpected($expected);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), count($actual));

        // 内容の比較
        for ($i = 0; $i < count($expected); $i++) {
            $this->assertSame($expected[$i], $actual[$i]);
        }
    }

    public static function deleteArrayProvider() {
        return self::expandKeyArray(
            TEST_KEY_PREFIX. 'hash_OK_test01',
            TEST_KEY_PREFIX. 'list_OK_*4',
            TEST_KEY_PREFIX. 'string_OK_test?2',
            TEST_KEY_PREFIX. 'set_OK_test0[24]'
        );
    }

    /**
     * delete: KEYパターン(*)
     *
     * @group delete
     * @group ok
     */
    public function testDeleteAsterisk() {
        $actual = self::$object->delete(TEST_KEY_PREFIX. '*');
        $expected = self::makeExpected(TEST_KEY_PREFIX. '*');

        // 0件同士でチェックしないように
        $this->assertTrue($actual > 0);

        // 予想と実行結果の件数比較
        $this->assertEquals(count($expected), $actual);

        // 残りは0
        $this->assertNull(self::$object->find(TEST_KEY_PREFIX. '*'));
    }

}
